"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadKTX2 = void 0;
exports.loadKTX2BufferToTexture = loadKTX2BufferToTexture;
exports.loadKTX2BufferToArray = loadKTX2BufferToArray;
/* eslint-disable @typescript-eslint/no-unsafe-argument */
const assets_1 = require("@pixi/assets");
const compressed_textures_1 = require("@pixi/compressed-textures");
const core_1 = require("@pixi/core");
const Basis_1 = require("../Basis");
const TranscoderWorkerKTX2_1 = require("../TranscoderWorkerKTX2");
const KTX2Parser_1 = require("./KTX2Parser");
/** Load KTX2 textures! */
exports.loadKTX2 = {
    extension: {
        type: core_1.ExtensionType.LoadParser,
        priority: assets_1.LoaderParserPriority.High,
    },
    name: 'loadKTX2',
    test(url) {
        return (0, assets_1.checkExtension)(url, '.ktx2');
    },
    load(url, asset, loader) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            yield TranscoderWorkerKTX2_1.TranscoderWorkerKTX2.onTranscoderInitialized;
            // get an array buffer...
            const response = yield core_1.settings.ADAPTER.fetch(url);
            const arrayBuffer = yield response.arrayBuffer();
            const resources = yield KTX2Parser_1.KTX2Parser.transcode(arrayBuffer);
            const type = (resources === null || resources === void 0 ? void 0 : resources.basisFormat) ? Basis_1.BASIS_FORMAT_TO_TYPE[resources === null || resources === void 0 ? void 0 : resources.basisFormat] : undefined;
            const format = (resources === null || resources === void 0 ? void 0 : resources.basisFormat) !== Basis_1.BASIS_FORMATS.cTFRGBA32 ? core_1.FORMATS.RGB : core_1.FORMATS.RGBA;
            const textures = (_a = resources === null || resources === void 0 ? void 0 : resources.map((resource) => {
                const base = new core_1.BaseTexture(resource, Object.assign({ mipmap: resource instanceof compressed_textures_1.CompressedTextureResource && resource.levels > 1 ? core_1.MIPMAP_MODES.ON_MANUAL : core_1.MIPMAP_MODES.OFF, alphaMode: core_1.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, type,
                    format }, asset.data));
                return (0, assets_1.createTexture)(base, loader, url);
            })) !== null && _a !== void 0 ? _a : [];
            return textures.length === 1 ? textures[0] : textures;
        });
    },
    unload(texture) {
        if (Array.isArray(texture)) {
            texture.forEach((t) => t.destroy(true));
        }
        else {
            texture.destroy(true);
        }
    },
};
core_1.extensions.add(exports.loadKTX2);
function loadKTX2BufferToTexture(byteArr, fileName, loader) {
    return __awaiter(this, void 0, void 0, function* () {
        yield TranscoderWorkerKTX2_1.TranscoderWorkerKTX2.onTranscoderInitialized;
        const resources = yield KTX2Parser_1.KTX2Parser.transcode(byteArr.buffer);
        const type = (resources === null || resources === void 0 ? void 0 : resources.basisFormat) ? Basis_1.BASIS_FORMAT_TO_TYPE[resources === null || resources === void 0 ? void 0 : resources.basisFormat] : undefined;
        const format = (resources === null || resources === void 0 ? void 0 : resources.basisFormat) !== Basis_1.BASIS_FORMATS.cTFRGBA32 ? core_1.FORMATS.RGB : core_1.FORMATS.RGBA;
        if (!resources || !resources[0])
            return undefined;
        const mainResource = resources[0];
        const base = new core_1.BaseTexture(mainResource, {
            mipmap: mainResource instanceof compressed_textures_1.CompressedTextureResource && mainResource.levels > 1 ? core_1.MIPMAP_MODES.ON_MANUAL : core_1.MIPMAP_MODES.OFF,
            alphaMode: core_1.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
            type,
            format,
        });
        const texture = (0, assets_1.createTexture)(base, loader, fileName);
        return texture;
    });
}
function loadKTX2BufferToArray(byteArr, fileName, loader) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield TranscoderWorkerKTX2_1.TranscoderWorkerKTX2.onTranscoderInitialized;
        const resources = yield KTX2Parser_1.KTX2Parser.transcode(byteArr.buffer);
        const type = (resources === null || resources === void 0 ? void 0 : resources.basisFormat) ? Basis_1.BASIS_FORMAT_TO_TYPE[resources === null || resources === void 0 ? void 0 : resources.basisFormat] : undefined;
        const format = (resources === null || resources === void 0 ? void 0 : resources.basisFormat) !== Basis_1.BASIS_FORMATS.cTFRGBA32 ? core_1.FORMATS.RGB : core_1.FORMATS.RGBA;
        const textures = (_a = resources === null || resources === void 0 ? void 0 : resources.map((resource) => {
            const base = new core_1.BaseTexture(resource, {
                mipmap: resource instanceof compressed_textures_1.CompressedTextureResource && resource.levels > 1 ? core_1.MIPMAP_MODES.ON_MANUAL : core_1.MIPMAP_MODES.OFF,
                alphaMode: core_1.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
                type,
                format,
            });
            const texture = (0, assets_1.createTexture)(base, loader, fileName);
            return texture;
        })) !== null && _a !== void 0 ? _a : [];
        return textures;
    });
}
//# sourceMappingURL=loadKTX2.js.map