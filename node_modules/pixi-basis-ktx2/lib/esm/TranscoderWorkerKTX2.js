"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranscoderWorkerKTX2 = void 0;
const TranscoderWorkerWrapperKTX2_1 = require("./TranscoderWorkerWrapperKTX2");
/**
 * Worker class for transcoding *.ktx2 files in background threads.
 *
 * To enable asynchronous transcoding, you need to provide the URL to the basis_universal transcoding
 * library.
 * @memberof PIXI.KTX2Parser
 */
class TranscoderWorkerKTX2 {
    // IMPLEMENTATION NOTE: TranscoderWorker tracks transcoding requests with a requestID; the worker can be issued
    // multiple requests (once it is initialized) and the response contains the requestID of the triggering request. Based on
    // the response, the transcodeAsync promise is fulfilled or rejected.
    static bindingURL;
    static jsSource;
    static wasmSource;
    static _onTranscoderInitializedResolve;
    /** a promise that when reslved means the transcoder is ready to be used */
    static onTranscoderInitialized = new Promise((resolve) => {
        TranscoderWorkerKTX2._onTranscoderInitializedResolve = resolve;
    });
    isInit;
    load;
    requests = {};
    static _workerURL;
    static _tempID = 0;
    /** Generated URL for the transcoder worker script. */
    static get workerURL() {
        if (!TranscoderWorkerKTX2._workerURL) {
            let workerSource = TranscoderWorkerWrapperKTX2_1.TranscoderWorkerWrapperKTX2.toString();
            const beginIndex = workerSource.indexOf('{');
            const endIndex = workerSource.lastIndexOf('}');
            workerSource = workerSource.slice(beginIndex + 1, endIndex);
            if (TranscoderWorkerKTX2.jsSource) {
                workerSource = `${TranscoderWorkerKTX2.jsSource}\n${workerSource}`;
            }
            TranscoderWorkerKTX2._workerURL = URL.createObjectURL(new Blob([workerSource]));
        }
        return TranscoderWorkerKTX2._workerURL;
    }
    worker;
    initPromise;
    onInit = () => { };
    constructor() {
        this.isInit = false;
        this.load = 0;
        this.initPromise = new Promise((resolve) => {
            this.onInit = resolve;
        });
        if (!TranscoderWorkerKTX2.wasmSource) {
            console.warn('resources.BasisResource.TranscoderWorker has not been given the transcoder WASM binary!');
        }
        this.worker = new Worker(TranscoderWorkerKTX2.workerURL);
        this.worker.onmessage = this.onMessage;
        this.worker.postMessage({
            type: 'init',
            jsSource: TranscoderWorkerKTX2.jsSource,
            wasmSource: TranscoderWorkerKTX2.wasmSource,
        });
    }
    /** @returns a promise that is resolved when the web-worker is initialized */
    initAsync() {
        return this.initPromise;
    }
    /**
     * Creates a promise that will resolve when the transcoding of a *.basis file is complete.
     * @param basisData - *.basis file contents
     * @param rgbaFormat - transcoding format for RGBA files
     * @param rgbFormat - transcoding format for RGB files
     * @returns a promise that is resolved with the transcoding response of the web-worker
     */
    async transcodeAsync(basisData, rgbaFormat, rgbFormat) {
        ++this.load;
        const requestID = TranscoderWorkerKTX2._tempID++;
        const requestPromise = new Promise((resolve, reject) => {
            this.requests[requestID] = {
                resolve,
                reject,
            };
        });
        this.worker.postMessage({
            requestID,
            basisData,
            rgbaFormat,
            rgbFormat,
            type: 'transcode',
        });
        return requestPromise;
    }
    /**
     * Handles responses from the web-worker
     * @param e - a message event containing the transcoded response
     */
    onMessage = (e) => {
        const data = e.data;
        if (data.type === 'init') {
            if (!data.success) {
                throw new Error('BasisResource.TranscoderWorker failed to initialize.');
            }
            this.isInit = true;
            this.onInit();
        }
        else if (data.type === 'transcode') {
            --this.load;
            const requestID = data.requestID;
            if (data.success) {
                this.requests[requestID].resolve(data);
            }
            else {
                this.requests[requestID].reject();
            }
            delete this.requests[requestID];
        }
    };
    /**
     * Loads the transcoder source code
     * @param jsURL - URL to the javascript basis transcoder
     * @param wasmURL - URL to the wasm basis transcoder
     * @returns A promise that resolves when both the js and wasm transcoders have been loaded.
     */
    static loadTranscoder(jsURL, wasmURL) {
        const jsPromise = fetch(jsURL)
            .then((res) => res.text())
            .then((text) => {
            TranscoderWorkerKTX2.jsSource = text;
        });
        const wasmPromise = fetch(wasmURL)
            .then((res) => res.arrayBuffer())
            .then((arrayBuffer) => {
            TranscoderWorkerKTX2.wasmSource = arrayBuffer;
        });
        return Promise.all([jsPromise, wasmPromise]).then((data) => {
            this._onTranscoderInitializedResolve();
            return data;
        });
    }
    /**
     * Set the transcoder source code directly
     * @param jsSource - source for the javascript basis transcoder
     * @param wasmSource - source for the wasm basis transcoder
     */
    static setTranscoder(jsSource, wasmSource) {
        TranscoderWorkerKTX2.jsSource = jsSource;
        TranscoderWorkerKTX2.wasmSource = wasmSource;
    }
}
exports.TranscoderWorkerKTX2 = TranscoderWorkerKTX2;
//# sourceMappingURL=TranscoderWorkerKTX2.js.map