"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadBasis = void 0;
exports.loadBasisBufferToTexture = loadBasisBufferToTexture;
exports.loadBasisBufferToArray = loadBasisBufferToArray;
/* eslint-disable @typescript-eslint/no-unsafe-argument */
const assets_1 = require("@pixi/assets");
const compressed_textures_1 = require("@pixi/compressed-textures");
const core_1 = require("@pixi/core");
const Basis_1 = require("../Basis");
const TranscoderWorkerBasis_1 = require("../TranscoderWorkerBasis");
const BasisParser_1 = require("./BasisParser");
/** Load BASIS textures! */
exports.loadBasis = {
    extension: {
        type: core_1.ExtensionType.LoadParser,
        priority: assets_1.LoaderParserPriority.High,
    },
    name: 'loadBasis',
    test(url) {
        return (0, assets_1.checkExtension)(url, '.basis');
    },
    async load(url, asset, loader) {
        await TranscoderWorkerBasis_1.TranscoderWorkerBasis.onTranscoderInitialized;
        // get an array buffer...
        const response = await core_1.settings.ADAPTER.fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const resources = await BasisParser_1.BasisParser.transcode(arrayBuffer);
        const type = resources?.basisFormat ? Basis_1.BASIS_FORMAT_TO_TYPE[resources?.basisFormat] : undefined;
        const format = resources?.basisFormat !== Basis_1.BASIS_FORMATS.cTFRGBA32 ? core_1.FORMATS.RGB : core_1.FORMATS.RGBA;
        const textures = resources?.map((resource) => {
            const base = new core_1.BaseTexture(resource, {
                mipmap: resource instanceof compressed_textures_1.CompressedTextureResource && resource.levels > 1 ? core_1.MIPMAP_MODES.ON_MANUAL : core_1.MIPMAP_MODES.OFF,
                alphaMode: core_1.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
                type,
                format,
                ...asset.data,
            });
            return (0, assets_1.createTexture)(base, loader, url);
        }) ?? [];
        return textures.length === 1 ? textures[0] : textures;
    },
    unload(texture) {
        if (Array.isArray(texture)) {
            texture.forEach((t) => t.destroy(true));
        }
        else {
            texture.destroy(true);
        }
    },
};
core_1.extensions.add(exports.loadBasis);
async function loadBasisBufferToTexture(byteArr, fileName, loader) {
    await TranscoderWorkerBasis_1.TranscoderWorkerBasis.onTranscoderInitialized;
    const resources = await BasisParser_1.BasisParser.transcode(byteArr.buffer);
    const type = resources?.basisFormat ? Basis_1.BASIS_FORMAT_TO_TYPE[resources?.basisFormat] : undefined;
    const format = resources?.basisFormat !== Basis_1.BASIS_FORMATS.cTFRGBA32 ? core_1.FORMATS.RGB : core_1.FORMATS.RGBA;
    if (!resources || !resources[0])
        return undefined;
    const mainResource = resources[0];
    const base = new core_1.BaseTexture(mainResource, {
        mipmap: mainResource instanceof compressed_textures_1.CompressedTextureResource && mainResource.levels > 1 ? core_1.MIPMAP_MODES.ON_MANUAL : core_1.MIPMAP_MODES.OFF,
        alphaMode: core_1.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        type,
        format,
    });
    const texture = (0, assets_1.createTexture)(base, loader, fileName);
    return texture;
}
async function loadBasisBufferToArray(byteArr, fileName, loader) {
    await TranscoderWorkerBasis_1.TranscoderWorkerBasis.onTranscoderInitialized;
    const resources = await BasisParser_1.BasisParser.transcode(byteArr.buffer);
    const type = resources?.basisFormat ? Basis_1.BASIS_FORMAT_TO_TYPE[resources?.basisFormat] : undefined;
    const format = resources?.basisFormat !== Basis_1.BASIS_FORMATS.cTFRGBA32 ? core_1.FORMATS.RGB : core_1.FORMATS.RGBA;
    const textures = resources?.map((resource) => {
        const base = new core_1.BaseTexture(resource, {
            mipmap: resource instanceof compressed_textures_1.CompressedTextureResource && resource.levels > 1 ? core_1.MIPMAP_MODES.ON_MANUAL : core_1.MIPMAP_MODES.OFF,
            alphaMode: core_1.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
            type,
            format,
        });
        const texture = (0, assets_1.createTexture)(base, loader, fileName);
        return texture;
    }) ?? [];
    return textures;
}
//# sourceMappingURL=loadBasis.js.map